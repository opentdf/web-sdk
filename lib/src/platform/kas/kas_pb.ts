// @generated by protoc-gen-es v2.2.5 with parameter "target=ts,import_extension=.js"
// @generated from file kas/kas.proto (package kas, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_api_annotations } from "../google/api/annotations_pb.js";
import type { StringValueSchema, Value } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_struct, file_google_protobuf_wrappers } from "@bufbuild/protobuf/wkt";
import { file_protoc_gen_openapiv2_options_annotations } from "../protoc-gen-openapiv2/options/annotations_pb.js";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file kas/kas.proto.
 */
export const file_kas_kas: GenFile = /*@__PURE__*/
  fileDesc("Cg1rYXMva2FzLnByb3RvEgNrYXMiDQoLSW5mb1JlcXVlc3QiHwoMSW5mb1Jlc3BvbnNlEg8KB3ZlcnNpb24YASABKAkiKwoWTGVnYWN5UHVibGljS2V5UmVxdWVzdBIRCglhbGdvcml0aG0YASABKAkiNQoNUG9saWN5QmluZGluZxIWCglhbGdvcml0aG0YASABKAlSA2FsZxIMCgRoYXNoGAIgASgJIvoBCglLZXlBY2Nlc3MSGgoSZW5jcnlwdGVkX21ldGFkYXRhGAEgASgJEioKDnBvbGljeV9iaW5kaW5nGAIgASgLMhIua2FzLlBvbGljeUJpbmRpbmcSEAoIcHJvdG9jb2wYAyABKAkSFgoIa2V5X3R5cGUYBCABKAlSBHR5cGUSFAoHa2FzX3VybBgFIAEoCVIDdXJsEgsKA2tpZBgGIAEoCRIVCghzcGxpdF9pZBgHIAEoCVIDc2lkEhMKC3dyYXBwZWRfa2V5GAggASgMEg4KBmhlYWRlchgJIAEoDBIcChRlcGhlbWVyYWxfcHVibGljX2tleRgKIAEoCSL5AwoVVW5zaWduZWRSZXdyYXBSZXF1ZXN0EhkKEWNsaWVudF9wdWJsaWNfa2V5GAEgASgJEj4KCHJlcXVlc3RzGAIgAygLMiwua2FzLlVuc2lnbmVkUmV3cmFwUmVxdWVzdC5XaXRoUG9saWN5UmVxdWVzdBImCgprZXlfYWNjZXNzGAMgASgLMg4ua2FzLktleUFjY2Vzc0ICGAESEgoGcG9saWN5GAQgASgJQgIYARIVCglhbGdvcml0aG0YBSABKAlCAhgBGiYKCldpdGhQb2xpY3kSCgoCaWQYASABKAkSDAoEYm9keRgCIAEoCRpeChNXaXRoS2V5QWNjZXNzT2JqZWN0EhwKFGtleV9hY2Nlc3Nfb2JqZWN0X2lkGAEgASgJEikKEWtleV9hY2Nlc3Nfb2JqZWN0GAIgASgLMg4ua2FzLktleUFjY2VzcxqpAQoRV2l0aFBvbGljeVJlcXVlc3QSSgoSa2V5X2FjY2Vzc19vYmplY3RzGAEgAygLMi4ua2FzLlVuc2lnbmVkUmV3cmFwUmVxdWVzdC5XaXRoS2V5QWNjZXNzT2JqZWN0EjUKBnBvbGljeRgCIAEoCzIlLmthcy5VbnNpZ25lZFJld3JhcFJlcXVlc3QuV2l0aFBvbGljeRIRCglhbGdvcml0aG0YAyABKAkingEKEFB1YmxpY0tleVJlcXVlc3QSRgoJYWxnb3JpdGhtGAEgASgJQjOSQTAyLmFsZ29yaXRobSB0eXBlIHJzYTo8a2V5c2l6ZT4gb3IgZWM6PGN1cnZlbmFtZT4SIQoDZm10GAIgASgJQhSSQREyD3Jlc3BvbnNlIGZvcm1hdBIfCgF2GAMgASgJQhSSQREyD3JlcXVlc3QgdmVyc2lvbiI0ChFQdWJsaWNLZXlSZXNwb25zZRISCgpwdWJsaWNfa2V5GAEgASgJEgsKA2tpZBgCIAEoCSI7Cg1SZXdyYXBSZXF1ZXN0EhwKFHNpZ25lZF9yZXF1ZXN0X3Rva2VuGAEgASgJSgQIAhADUgZiZWFyZXIigAIKFUtleUFjY2Vzc1Jld3JhcFJlc3VsdBI6CghtZXRhZGF0YRgBIAMoCzIoLmthcy5LZXlBY2Nlc3NSZXdyYXBSZXN1bHQuTWV0YWRhdGFFbnRyeRIcChRrZXlfYWNjZXNzX29iamVjdF9pZBgCIAEoCRIOCgZzdGF0dXMYAyABKAkSGQoPa2FzX3dyYXBwZWRfa2V5GAQgASgMSAASDwoFZXJyb3IYBSABKAlIABpHCg1NZXRhZGF0YUVudHJ5EgsKA2tleRgBIAEoCRIlCgV2YWx1ZRgCIAEoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZToCOAFCCAoGcmVzdWx0IlQKElBvbGljeVJld3JhcFJlc3VsdBIRCglwb2xpY3lfaWQYASABKAkSKwoHcmVzdWx0cxgCIAMoCzIaLmthcy5LZXlBY2Nlc3NSZXdyYXBSZXN1bHQilgIKDlJld3JhcFJlc3BvbnNlEjcKCG1ldGFkYXRhGAEgAygLMiEua2FzLlJld3JhcFJlc3BvbnNlLk1ldGFkYXRhRW50cnlCAhgBEh4KEmVudGl0eV93cmFwcGVkX2tleRgCIAEoDEICGAESGgoSc2Vzc2lvbl9wdWJsaWNfa2V5GAMgASgJEhoKDnNjaGVtYV92ZXJzaW9uGAQgASgJQgIYARIqCglyZXNwb25zZXMYBSADKAsyFy5rYXMuUG9saWN5UmV3cmFwUmVzdWx0GkcKDU1ldGFkYXRhRW50cnkSCwoDa2V5GAEgASgJEiUKBXZhbHVlGAIgASgLMhYuZ29vZ2xlLnByb3RvYnVmLlZhbHVlOgI4ATLRAgoNQWNjZXNzU2VydmljZRJpCglQdWJsaWNLZXkSFS5rYXMuUHVibGljS2V5UmVxdWVzdBoWLmthcy5QdWJsaWNLZXlSZXNwb25zZSItkAIBkkEJSgcKAzIwMBIAgtPkkwIYEhYva2FzL3YyL2thc19wdWJsaWNfa2V5EnsKD0xlZ2FjeVB1YmxpY0tleRIbLmthcy5MZWdhY3lQdWJsaWNLZXlSZXF1ZXN0GhwuZ29vZ2xlLnByb3RvYnVmLlN0cmluZ1ZhbHVlIi2IAgGQAgGSQQlKBwoDMjAwEgCC0+STAhUSEy9rYXMva2FzX3B1YmxpY19rZXkSWAoGUmV3cmFwEhIua2FzLlJld3JhcFJlcXVlc3QaEy5rYXMuUmV3cmFwUmVzcG9uc2UiJZJBCUoHCgMyMDASAILT5JMCEzoBKiIOL2thcy92Mi9yZXdyYXBCdpJBcxJxChpPcGVuVERGIEtleSBBY2Nlc3MgU2VydmljZSpMChJCU0QgMy1DbGF1c2UgQ2xlYXISNmh0dHBzOi8vZ2l0aHViLmNvbS9vcGVudGRmL2JhY2tlbmQvYmxvYi9tYXN0ZXIvTElDRU5TRTIFMS41LjBiBnByb3RvMw", [file_google_api_annotations, file_google_protobuf_struct, file_google_protobuf_wrappers, file_protoc_gen_openapiv2_options_annotations]);

/**
 * Intentionally empty. May include features later.
 *
 * @generated from message kas.InfoRequest
 */
export type InfoRequest = Message<"kas.InfoRequest"> & {
};

/**
 * Describes the message kas.InfoRequest.
 * Use `create(InfoRequestSchema)` to create a new message.
 */
export const InfoRequestSchema: GenMessage<InfoRequest> = /*@__PURE__*/
  messageDesc(file_kas_kas, 0);

/**
 * Service application level metadata
 *
 * @generated from message kas.InfoResponse
 */
export type InfoResponse = Message<"kas.InfoResponse"> & {
  /**
   * @generated from field: string version = 1;
   */
  version: string;
};

/**
 * Describes the message kas.InfoResponse.
 * Use `create(InfoResponseSchema)` to create a new message.
 */
export const InfoResponseSchema: GenMessage<InfoResponse> = /*@__PURE__*/
  messageDesc(file_kas_kas, 1);

/**
 * @generated from message kas.LegacyPublicKeyRequest
 */
export type LegacyPublicKeyRequest = Message<"kas.LegacyPublicKeyRequest"> & {
  /**
   * @generated from field: string algorithm = 1;
   */
  algorithm: string;
};

/**
 * Describes the message kas.LegacyPublicKeyRequest.
 * Use `create(LegacyPublicKeyRequestSchema)` to create a new message.
 */
export const LegacyPublicKeyRequestSchema: GenMessage<LegacyPublicKeyRequest> = /*@__PURE__*/
  messageDesc(file_kas_kas, 2);

/**
 * Policy binding ensures cryptographic integrity between policy and wrapped key
 * Prevents policy tampering by binding the policy hash to the encrypted key
 *
 * @generated from message kas.PolicyBinding
 */
export type PolicyBinding = Message<"kas.PolicyBinding"> & {
  /**
   * Cryptographic hashing algorithm used for policy binding
   * Optional: ZTDF (when policy_binding is an object)
   * Value: Always "HS256" (HMAC-SHA256) - other algorithms not supported
   * Example: "HS256"
   *
   * @generated from field: string algorithm = 1 [json_name = "alg"];
   */
  algorithm: string;

  /**
   * HMAC-SHA256 hash of the base64-encoded policy using the DEK as the secret key
   * 4.2.2 TDFs are hex and base64 encoded before HMAC computation
   * Required: ZTDF (when policy_binding is an object)
   * Links the policy content to the wrapped DEK cryptographically via HMAC
   * Computed as HMAC-SHA256(DEK, base64_policy) then hex-encoded and base64-encoded
   *
   * @generated from field: string hash = 2;
   */
  hash: string;
};

/**
 * Describes the message kas.PolicyBinding.
 * Use `create(PolicyBindingSchema)` to create a new message.
 */
export const PolicyBindingSchema: GenMessage<PolicyBinding> = /*@__PURE__*/
  messageDesc(file_kas_kas, 3);

/**
 * Key Access Object containing cryptographic material and metadata for TDF decryption
 *
 * @generated from message kas.KeyAccess
 */
export type KeyAccess = Message<"kas.KeyAccess"> & {
  /**
   * Base64-encoded encrypted metadata containing additional key information
   * Optional: Not used during KAS rewrap operations (client-side only)
   * KAS service passes this through without processing or validation
   *
   * @generated from field: string encrypted_metadata = 1;
   */
  encryptedMetadata: string;

  /**
   * Policy binding ensuring cryptographic integrity between policy and wrapped key
   * Required: ZTDF (contains hash and algorithm)
   * Links the policy to the wrapped key cryptographically
   *
   * @generated from field: kas.PolicyBinding policy_binding = 2;
   */
  policyBinding?: PolicyBinding;

  /**
   * Protocol identifier for the key access mechanism
   * Optional: Defaults to 'kas'
   * Typically: 'kas' for standard Key Access Service protocol
   * Example: "kas"
   *
   * @generated from field: string protocol = 3;
   */
  protocol: string;

  /**
   * Type of key wrapping used for the data encryption key
   * Required: Always
   * Values: 'wrapped' (RSA-wrapped for ZTDF), 'ec-wrapped' (experimental ECDH-wrapped)
   *
   * @generated from field: string key_type = 4 [json_name = "type"];
   */
  keyType: string;

  /**
   * URL of the Key Access Server that can unwrap this key
   * Optional: May be omitted if KAS URL is known from context
   * Used to route rewrap requests to the correct KAS instance
   * Example: "https://kas.example.com"
   *
   * @generated from field: string kas_url = 5 [json_name = "url"];
   */
  kasUrl: string;

  /**
   * Key identifier for the KAS public key used for wrapping
   * Optional: ZTDF (may specify which KAS key to use, required if present in the TDF)
   * References a specific public key in the KAS key storage (either local keyring or KAS Registry service)
   * Example: "k1", "ec-key-2024"
   *
   * @generated from field: string kid = 6;
   */
  kid: string;

  /**
   * Split identifier for key splitting scenarios
   * Optional: ZTDF (used in advanced key splitting configurations)
   * Used when keys are split across multiple parties for enhanced security
   *
   * @generated from field: string split_id = 7 [json_name = "sid"];
   */
  splitId: string;

  /**
   * Client-generated data encryption key wrapped by KAS
   * Required: Always
   * Contains the actual DEK encrypted with KAS's public key
   * This is the core cryptographic material needed for TDF decryption
   *
   * @generated from field: bytes wrapped_key = 8;
   */
  wrappedKey: Uint8Array;

  /**
   * Complete header containing all metadata and policy information (for formats that embed it)
   * Optional: Not used by ZTDF (policy and metadata are separate)
   * Contains magic bytes, version, algorithm, policy, and ephemeral key information
   *
   * @generated from field: bytes header = 9;
   */
  header: Uint8Array;

  /**
   * Ephemeral public key for ECDH key derivation (ec-wrapped type only)
   * Required: When key_type="ec-wrapped" (experimental ECDH-based ZTDF)
   * Omitted: When key_type="wrapped" (RSA-based ZTDF)
   * Should be a PEM-encoded PKCS#8 (ASN.1) formatted public key
   * Used to derive the symmetric key for unwrapping the DEK
   *
   * @generated from field: string ephemeral_public_key = 10;
   */
  ephemeralPublicKey: string;
};

/**
 * Describes the message kas.KeyAccess.
 * Use `create(KeyAccessSchema)` to create a new message.
 */
export const KeyAccessSchema: GenMessage<KeyAccess> = /*@__PURE__*/
  messageDesc(file_kas_kas, 4);

/**
 * Bulk-style Rewrap request structure that is serialized into JSON and signed
 * within a Rewrap flow. This message represents the unsigned payload that gets
 * embedded in a JWT as the 'requestBody' claim and signed with a DPoP key.
 *
 * @generated from message kas.UnsignedRewrapRequest
 */
export type UnsignedRewrapRequest = Message<"kas.UnsignedRewrapRequest"> & {
  /**
   * Client's public key in PEM format for establishing a session key
   * Required: Always
   * Used by KAS to generate an ephemeral session key for secure key exchange
   *
   * @generated from field: string client_public_key = 1;
   */
  clientPublicKey: string;

  /**
   * List of policy requests to be processed
   * Required: Always (at least one)
   * Each request represents a policy with its associated key access objects
   *
   * @generated from field: repeated kas.UnsignedRewrapRequest.WithPolicyRequest requests = 2;
   */
  requests: UnsignedRewrapRequest_WithPolicyRequest[];

  /**
   * Deprecated: Legacy single Key Access Object
   * Used for legacy non-bulk requests (v1 API)
   * Modern clients should use the 'requests' field instead
   *
   * @generated from field: kas.KeyAccess key_access = 3 [deprecated = true];
   * @deprecated
   */
  keyAccess?: KeyAccess;

  /**
   * Deprecated: Legacy single policy
   * Used for legacy non-bulk requests (v1 API)
   * Modern clients should use the 'requests' field instead
   *
   * @generated from field: string policy = 4 [deprecated = true];
   * @deprecated
   */
  policy: string;

  /**
   * Deprecated: Legacy algorithm specification
   * Used for legacy non-bulk requests (v1 API)  
   * Modern clients should use the 'requests' field instead
   *
   * @generated from field: string algorithm = 5 [deprecated = true];
   * @deprecated
   */
  algorithm: string;
};

/**
 * Describes the message kas.UnsignedRewrapRequest.
 * Use `create(UnsignedRewrapRequestSchema)` to create a new message.
 */
export const UnsignedRewrapRequestSchema: GenMessage<UnsignedRewrapRequest> = /*@__PURE__*/
  messageDesc(file_kas_kas, 5);

/**
 * Policy metadata and content for a group of KeyAccessObjects
 *
 * @generated from message kas.UnsignedRewrapRequest.WithPolicy
 */
export type UnsignedRewrapRequest_WithPolicy = Message<"kas.UnsignedRewrapRequest.WithPolicy"> & {
  /**
   * An identifier unique within the scope of the rewrap request
   * Used for mapping between request and response items.
   * Required: Always
   * Example: "policy", "policy-0", "policy-1"
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Policy content - format varies by TDF type:
   * ZTDF: Base64-encoded JSON policy object containing attributes and other policy data
   * Required: ZTDF (base64-encoded policy JSON)
   *
   * @generated from field: string body = 2;
   */
  body: string;
};

/**
 * Describes the message kas.UnsignedRewrapRequest.WithPolicy.
 * Use `create(UnsignedRewrapRequest_WithPolicySchema)` to create a new message.
 */
export const UnsignedRewrapRequest_WithPolicySchema: GenMessage<UnsignedRewrapRequest_WithPolicy> = /*@__PURE__*/
  messageDesc(file_kas_kas, 5, 0);

/**
 * Key Access Object wrapper with identifier
 *
 * @generated from message kas.UnsignedRewrapRequest.WithKeyAccessObject
 */
export type UnsignedRewrapRequest_WithKeyAccessObject = Message<"kas.UnsignedRewrapRequest.WithKeyAccessObject"> & {
  /**
   * Ephemeral, unique identifier for this KAO within the request
   * Required: Always
   * Example: "kao-0", "kao-1", "key-access-object-uuid"
   *
   * @generated from field: string key_access_object_id = 1;
   */
  keyAccessObjectId: string;

  /**
   * The actual Key Access Object containing cryptographic material and metadata
   * Required: Always
   *
   * @generated from field: kas.KeyAccess key_access_object = 2;
   */
  keyAccessObject?: KeyAccess;
};

/**
 * Describes the message kas.UnsignedRewrapRequest.WithKeyAccessObject.
 * Use `create(UnsignedRewrapRequest_WithKeyAccessObjectSchema)` to create a new message.
 */
export const UnsignedRewrapRequest_WithKeyAccessObjectSchema: GenMessage<UnsignedRewrapRequest_WithKeyAccessObject> = /*@__PURE__*/
  messageDesc(file_kas_kas, 5, 1);

/**
 * Request grouping policy with associated key access objects
 *
 * @generated from message kas.UnsignedRewrapRequest.WithPolicyRequest
 */
export type UnsignedRewrapRequest_WithPolicyRequest = Message<"kas.UnsignedRewrapRequest.WithPolicyRequest"> & {
  /**
   * List of Key Access Objects associated with this policy
   * Required: Always (at least one)
   * Some formats require exactly one KAO per policy
   *
   * @generated from field: repeated kas.UnsignedRewrapRequest.WithKeyAccessObject key_access_objects = 1;
   */
  keyAccessObjects: UnsignedRewrapRequest_WithKeyAccessObject[];

  /**
   * Policy information for this group of KAOs
   * Required: Always
   *
   * @generated from field: kas.UnsignedRewrapRequest.WithPolicy policy = 2;
   */
  policy?: UnsignedRewrapRequest_WithPolicy;

  /**
   * Cryptographic algorithm identifier for the TDF type
   * Optional: Defaults to rsa:2048 if omitted
   * Values: "ec:secp256r1" (EC-based), "rsa:2048" (RSA-based), "" (defaults to rsa:2048)
   * Example: "ec:secp256r1"
   *
   * @generated from field: string algorithm = 3;
   */
  algorithm: string;
};

/**
 * Describes the message kas.UnsignedRewrapRequest.WithPolicyRequest.
 * Use `create(UnsignedRewrapRequest_WithPolicyRequestSchema)` to create a new message.
 */
export const UnsignedRewrapRequest_WithPolicyRequestSchema: GenMessage<UnsignedRewrapRequest_WithPolicyRequest> = /*@__PURE__*/
  messageDesc(file_kas_kas, 5, 2);

/**
 * @generated from message kas.PublicKeyRequest
 */
export type PublicKeyRequest = Message<"kas.PublicKeyRequest"> & {
  /**
   * @generated from field: string algorithm = 1;
   */
  algorithm: string;

  /**
   * @generated from field: string fmt = 2;
   */
  fmt: string;

  /**
   * @generated from field: string v = 3;
   */
  v: string;
};

/**
 * Describes the message kas.PublicKeyRequest.
 * Use `create(PublicKeyRequestSchema)` to create a new message.
 */
export const PublicKeyRequestSchema: GenMessage<PublicKeyRequest> = /*@__PURE__*/
  messageDesc(file_kas_kas, 6);

/**
 * @generated from message kas.PublicKeyResponse
 */
export type PublicKeyResponse = Message<"kas.PublicKeyResponse"> & {
  /**
   * @generated from field: string public_key = 1;
   */
  publicKey: string;

  /**
   * @generated from field: string kid = 2;
   */
  kid: string;
};

/**
 * Describes the message kas.PublicKeyResponse.
 * Use `create(PublicKeyResponseSchema)` to create a new message.
 */
export const PublicKeyResponseSchema: GenMessage<PublicKeyResponse> = /*@__PURE__*/
  messageDesc(file_kas_kas, 7);

/**
 * Request to rewrap (decrypt and re-encrypt) TDF keys for client access
 *
 * @generated from message kas.RewrapRequest
 */
export type RewrapRequest = Message<"kas.RewrapRequest"> & {
  /**
   * A JWT signed by the DPoP (Demonstration of Proof of Possession) private key
   * Required: Always
   * Version differences:
   * - v1 (legacy): Uses existing TDF spec schema in requestBody
   * - v2 (bulk): Uses UnsignedRewrapRequest proto serialized as JSON in requestBody
   *
   * @generated from field: string signed_request_token = 1;
   */
  signedRequestToken: string;
};

/**
 * Describes the message kas.RewrapRequest.
 * Use `create(RewrapRequestSchema)` to create a new message.
 */
export const RewrapRequestSchema: GenMessage<RewrapRequest> = /*@__PURE__*/
  messageDesc(file_kas_kas, 8);

/**
 * Result of a key access object rewrap operation
 *
 * @generated from message kas.KeyAccessRewrapResult
 */
export type KeyAccessRewrapResult = Message<"kas.KeyAccessRewrapResult"> & {
  /**
   * Metadata associated with this KAO result (e.g., required obligations)
   * Optional: May contain obligation requirements or other policy metadata
   * Common keys: "X-Required-Obligations" with array of obligation FQNs
   *
   * @generated from field: map<string, google.protobuf.Value> metadata = 1;
   */
  metadata: { [key: string]: Value };

  /**
   * Identifier matching the key_access_object_id from the request
   * Required: Always matches the ID from UnsignedRewrapRequest_WithKeyAccessObject
   *
   * @generated from field: string key_access_object_id = 2;
   */
  keyAccessObjectId: string;

  /**
   * Status of the rewrap operation for this KAO
   * Required: Always
   * Values: "permit" (success), "fail" (failure)
   *
   * @generated from field: string status = 3;
   */
  status: string;

  /**
   * Result of the rewrap operation - either success or error
   *
   * @generated from oneof kas.KeyAccessRewrapResult.result
   */
  result: {
    /**
     * Successfully rewrapped key encrypted with the session key
     * Present when status="permit"
     * Contains the DEK encrypted with the ephemeral session key
     *
     * @generated from field: bytes kas_wrapped_key = 4;
     */
    value: Uint8Array;
    case: "kasWrappedKey";
  } | {
    /**
     * Error message when rewrap failed
     * Present when status="fail"
     * Human-readable description of the failure reason
     *
     * @generated from field: string error = 5;
     */
    value: string;
    case: "error";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message kas.KeyAccessRewrapResult.
 * Use `create(KeyAccessRewrapResultSchema)` to create a new message.
 */
export const KeyAccessRewrapResultSchema: GenMessage<KeyAccessRewrapResult> = /*@__PURE__*/
  messageDesc(file_kas_kas, 9);

/**
 * Result for all KAOs associated with a single policy
 *
 * @generated from message kas.PolicyRewrapResult
 */
export type PolicyRewrapResult = Message<"kas.PolicyRewrapResult"> & {
  /**
   * Policy identifier matching the policy.id from the request
   * Required: Always matches the ID from UnsignedRewrapRequest_WithPolicy
   *
   * @generated from field: string policy_id = 1;
   */
  policyId: string;

  /**
   * Results for each KAO under this policy
   * Required: One result per KAO in the original request
   *
   * @generated from field: repeated kas.KeyAccessRewrapResult results = 2;
   */
  results: KeyAccessRewrapResult[];
};

/**
 * Describes the message kas.PolicyRewrapResult.
 * Use `create(PolicyRewrapResultSchema)` to create a new message.
 */
export const PolicyRewrapResultSchema: GenMessage<PolicyRewrapResult> = /*@__PURE__*/
  messageDesc(file_kas_kas, 10);

/**
 * Response containing rewrapped keys and session information
 *
 * @generated from message kas.RewrapResponse
 */
export type RewrapResponse = Message<"kas.RewrapResponse"> & {
  /**
   * Deprecated: Legacy metadata field
   * Modern responses use metadata in individual KeyAccessRewrapResult
   *
   * @generated from field: map<string, google.protobuf.Value> metadata = 1 [deprecated = true];
   * @deprecated
   */
  metadata: { [key: string]: Value };

  /**
   * Deprecated: Legacy single entity wrapped key
   * Modern responses use kas_wrapped_key in KeyAccessRewrapResult
   *
   * @generated from field: bytes entity_wrapped_key = 2 [deprecated = true];
   * @deprecated
   */
  entityWrappedKey: Uint8Array;

  /**
   * KAS's ephemeral session public key in PEM format
   * Required: For EC-based operations (key_type="ec-wrapped")
   * Optional: Empty for RSA-based ZTDF (key_type="wrapped")
   * Used by client to perform ECDH key agreement and decrypt the kas_wrapped_key values
   *
   * @generated from field: string session_public_key = 3;
   */
  sessionPublicKey: string;

  /**
   * Deprecated: Legacy schema version identifier
   * Modern responses use implicit versioning
   *
   * @generated from field: string schema_version = 4 [deprecated = true];
   * @deprecated
   */
  schemaVersion: string;

  /**
   * Policy-grouped rewrap results for the bulk API
   * Required: Modern v2 API responses
   * Each PolicyRewrapResult contains results for all KAOs under that policy
   *
   * @generated from field: repeated kas.PolicyRewrapResult responses = 5;
   */
  responses: PolicyRewrapResult[];
};

/**
 * Describes the message kas.RewrapResponse.
 * Use `create(RewrapResponseSchema)` to create a new message.
 */
export const RewrapResponseSchema: GenMessage<RewrapResponse> = /*@__PURE__*/
  messageDesc(file_kas_kas, 11);

/**
 * Get app info from the root path
 *
 * @generated from service kas.AccessService
 */
export const AccessService: GenService<{
  /**
   * @generated from rpc kas.AccessService.PublicKey
   */
  publicKey: {
    methodKind: "unary";
    input: typeof PublicKeyRequestSchema;
    output: typeof PublicKeyResponseSchema;
  },
  /**
   * Endpoint intended for gRPC Gateway's REST endpoint to provide v1 compatibility with older TDF clients
   *
   * This endpoint is not recommended for use in new applications, prefer the v2 endpoint ('PublicKey') instead.
   *
   * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
   *
   * @generated from rpc kas.AccessService.LegacyPublicKey
   * @deprecated
   */
  legacyPublicKey: {
    methodKind: "unary";
    input: typeof LegacyPublicKeyRequestSchema;
    output: typeof StringValueSchema;
  },
  /**
   * @generated from rpc kas.AccessService.Rewrap
   */
  rewrap: {
    methodKind: "unary";
    input: typeof RewrapRequestSchema;
    output: typeof RewrapResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_kas_kas, 0);

